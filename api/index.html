


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Recommended Use &mdash; skfuzzy v0.4.2 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.4.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="skfuzzy v0.4.2 docs" href="../index.html" />
        <link rel="next" title="Pre-built installation" href="../install.html" />
        <link rel="prev" title="SciKit-Fuzzy" href="../overview.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="../index.html" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="../index.html">Home</a></li>
<li><a href="../user_guide.html">User Guide</a></li>
<li><a href="../auto_examples/index.html">Example Gallery</a></li>
<li><a href="#">API Documentation</a></li>
<li><a href="https://github.com/scikit-fuzzy/scikit-fuzzy">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <span class="target" id="module-skfuzzy"></span><p>scikit-fuzzy (a.k.a. <cite>skfuzzy</cite>): Fuzzy Logic Toolbox for Python.</p>
<p>This package implements many useful tools and functions for computation and
projects involving fuzzy logic, also known as grey logic.</p>
<p>Most of the functionality is actually located in subpackages, but like numpy we
bring most of the core functionality into the base namespace.</p>
<div class="section" id="recommended-use">
<h1>Recommended Use<a class="headerlink" href="#recommended-use" title="Permalink to this headline">¶</a></h1>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skfuzzy</span> <span class="k">as</span> <span class="nn">fuzz</span>
</pre></div>
</div>
<dl class="py exception">
<dt id="skfuzzy.DefuzzifyError">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">DefuzzifyError</span></code><a class="reference internal" href="../_modules/skfuzzy/defuzzify/exceptions.html#DefuzzifyError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.DefuzzifyError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py exception">
<dt id="skfuzzy.EmptyMembershipError">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">EmptyMembershipError</span></code><a class="reference internal" href="../_modules/skfuzzy/defuzzify/exceptions.html#EmptyMembershipError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.EmptyMembershipError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py exception">
<dt id="skfuzzy.InconsistentMFDataError">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">InconsistentMFDataError</span></code><a class="reference internal" href="../_modules/skfuzzy/defuzzify/exceptions.html#InconsistentMFDataError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.InconsistentMFDataError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="skfuzzy.addval">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">addval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#addval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.addval" title="Permalink to this definition">¶</a></dt>
<dd><p>Add intervals interval1 and interval2.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>interval1</strong><span class="classifier">2-element iterable</span></dt><dd><p>First interval set.</p>
</dd>
<dt><strong>interval2</strong><span class="classifier">2-element iterable</span></dt><dd><p>Second interval set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>Z</strong><span class="classifier">2-element array</span></dt><dd><p>Sum of interval1 and interval2, defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Z</span> <span class="o">=</span> <span class="n">interval1</span> <span class="o">+</span> <span class="n">interval2</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.arglcut">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">arglcut</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdacut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/defuzzify/defuzz.html#arglcut"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.arglcut" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the subset of indices <cite>mi</cite> of the elements in an N-point
resultant fuzzy membership sequence <cite>ms</cite> that have a grade of membership
&gt;= lambdacut.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ms</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership sequence.</p>
</dd>
<dt><strong>lambdacut</strong><span class="classifier">float</span></dt><dd><p>Value used for lambda cutting.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lidx</strong><span class="classifier">1d array</span></dt><dd><p>Indices corresponding to the lambda-cut subset of <cite>ms</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a convenience function for <cite>np.nonzero(lambdacut &lt;= ms)</cite> and only
half of the indexing operation that can be more concisely accomplished
via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ms</span><span class="p">[</span><span class="n">lambdacut</span> <span class="o">&lt;=</span> <span class="n">ms</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.cartadd">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">cartadd</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#cartadd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.cartadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian addition of fuzzy membership vectors using the algebraic method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1D array or iterable</span></dt><dd><p>First fuzzy membership vector, of length M.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1D array or iterable</span></dt><dd><p>Second fuzzy membership vector, of length N.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">2D array</span></dt><dd><p>Cartesian addition of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, of shape (M, N).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.cartprod">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">cartprod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#cartprod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.cartprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian product of two fuzzy membership vectors. Uses <code class="docutils literal notranslate"><span class="pre">min()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1D array or iterable</span></dt><dd><p>First fuzzy membership vector, of length M.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1D array or iterable</span></dt><dd><p>Second fuzzy membership vector, of length N.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">2D array</span></dt><dd><p>Cartesian product of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, of shape (M, N).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.centroid">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">centroid</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/defuzzify/defuzz.html#centroid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Defuzzification using centroid (<cite>center of gravity</cite>) method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length M</span></dt><dd><p>Independent variable</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array, length M</span></dt><dd><p>Fuzzy membership function</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">1d array, length M</span></dt><dd><p>Defuzzified result</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.defuzzify.defuzz</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.defuzzify.dcentroid</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.classic_relation">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">classic_relation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#classic_relation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.classic_relation" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the classic relation matrix, <code class="docutils literal notranslate"><span class="pre">R</span></code>, between two fuzzy sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">1D array or iterable</span></dt><dd><p>First fuzzy membership vector, of length M.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1D array or iterable</span></dt><dd><p>Second fuzzy membership vector, of length N.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">2D array</span></dt><dd><p>Classic relation matrix between <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, shape (M, N)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The classic relation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="n">x</span> <span class="n">b</span><span class="p">]</span> <span class="n">U</span> <span class="p">[(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="n">x</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)],</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> represents a cartesian product and <code class="docutils literal notranslate"><span class="pre">N</span></code> is len(<code class="docutils literal notranslate"><span class="pre">b</span></code>).</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.cmeans">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">cmeans</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/cluster/_cmeans.html#cmeans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.cmeans" title="Permalink to this definition">¶</a></dt>
<dd><p>Fuzzy c-means clustering algorithm [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">2d array, size (S, N)</span></dt><dd><p>Data to be clustered.  N is the number of data sets; S is the number
of features within each sample vector.</p>
</dd>
<dt><strong>c</strong><span class="classifier">int</span></dt><dd><p>Desired number of clusters or classes.</p>
</dd>
<dt><strong>m</strong><span class="classifier">float</span></dt><dd><p>Array exponentiation applied to the membership function u_old at each
iteration, where U_new = u_old ** m.</p>
</dd>
<dt><strong>error</strong><span class="classifier">float</span></dt><dd><p>Stopping criterion; stop early if the norm of (u[p] - u[p-1]) &lt; error.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations allowed.</p>
</dd>
<dt><strong>metric: string</strong></dt><dd><p>By default is set to euclidean. Passes any option accepted by
<code class="docutils literal notranslate"><span class="pre">scipy.spatial.distance.cdist</span></code>.</p>
</dd>
<dt><strong>init</strong><span class="classifier">2d array, size (c, N)</span></dt><dd><p>Initial fuzzy c-partitioned matrix. If none provided, algorithm is
randomly initialized.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>If provided, sets random seed of init. No effect if init is
provided. Mainly for debug/testing purposes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cntr</strong><span class="classifier">2d array, size (c, S)</span></dt><dd><p>Cluster centers.  Data for each center along each feature provided
for every cluster (of the <cite>c</cite> requested clusters).</p>
</dd>
<dt><strong>u</strong><span class="classifier">2d array, (c, N)</span></dt><dd><p>Final fuzzy c-partitioned matrix.</p>
</dd>
<dt><strong>u0</strong><span class="classifier">2d array, (c, N)</span></dt><dd><p>Initial guess at fuzzy c-partitioned matrix (either provided init or
random guess used if init was not provided).</p>
</dd>
<dt><strong>d</strong><span class="classifier">2d array, (c, N)</span></dt><dd><p>Final Euclidian distance matrix.</p>
</dd>
<dt><strong>jm</strong><span class="classifier">1d array, length P</span></dt><dd><p>Objective function history.</p>
</dd>
<dt><strong>p</strong><span class="classifier">int</span></dt><dd><p>Number of iterations run.</p>
</dd>
<dt><strong>fpc</strong><span class="classifier">float</span></dt><dd><p>Final fuzzy partition coefficient.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm implemented is from Ross et al. <a class="reference internal" href="#r7bb597fb7b53-1" id="id1">[1]</a>.</p>
<p>Fuzzy C-Means has a known problem with high dimensionality datasets, where
the majority of cluster centers are pulled into the overall center of
gravity. If you are clustering data with very high dimensionality and
encounter this issue, another clustering method may be required. For more
information and the theory behind this, see Winkler et al. <a class="reference internal" href="#r7bb597fb7b53-2" id="id2">[2]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7bb597fb7b53-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Ross, Timothy J. Fuzzy Logic With Engineering Applications, 3rd ed.
Wiley. 2010. ISBN 978-0-470-74376-8 pp 352-353, eq 10.28 - 10.35.</p>
</dd>
<dt class="label" id="r7bb597fb7b53-2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Winkler, R., Klawonn, F., &amp; Kruse, R. Fuzzy c-means in high
dimensional spaces. 2012. Contemporary Theory and Pragmatic
Approaches in Fuzzy Computing Utilization, 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.cmeans_predict">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">cmeans_predict</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cntr_trained</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/cluster/_cmeans.html#cmeans_predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.cmeans_predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Prediction of new data in given a trained fuzzy c-means framework [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>test_data</strong><span class="classifier">2d array, size (S, N)</span></dt><dd><p>New, independent data set to be predicted based on trained c-means
from <code class="docutils literal notranslate"><span class="pre">cmeans</span></code>. N is the number of data sets; S is the number of
features within each sample vector.</p>
</dd>
<dt><strong>cntr_trained</strong><span class="classifier">2d array, size (c, S)</span></dt><dd><p>Location of trained centers from prior training c-means.</p>
</dd>
<dt><strong>m</strong><span class="classifier">float</span></dt><dd><p>Array exponentiation applied to the membership function u_old at each
iteration, where U_new = u_old ** m.</p>
</dd>
<dt><strong>error</strong><span class="classifier">float</span></dt><dd><p>Stopping criterion; stop early if the norm of (u[p] - u[p-1]) &lt; error.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations allowed.</p>
</dd>
<dt><strong>metric: string</strong></dt><dd><p>By default is set to euclidean. Passes any option accepted by
<code class="docutils literal notranslate"><span class="pre">scipy.spatial.distance.cdist</span></code>.</p>
</dd>
<dt><strong>init</strong><span class="classifier">2d array, size (c, N)</span></dt><dd><p>Initial fuzzy c-partitioned matrix. If none provided, algorithm is
randomly initialized.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>If provided, sets random seed of init. No effect if init is
provided. Mainly for debug/testing purposes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">2d array, (c, N)</span></dt><dd><p>Final fuzzy c-partitioned matrix.</p>
</dd>
<dt><strong>u0</strong><span class="classifier">2d array, (c, N)</span></dt><dd><p>Initial guess at fuzzy c-partitioned matrix (either provided init or
random guess used if init was not provided).</p>
</dd>
<dt><strong>d</strong><span class="classifier">2d array, (c, N)</span></dt><dd><p>Final Euclidian distance matrix.</p>
</dd>
<dt><strong>jm</strong><span class="classifier">1d array, length P</span></dt><dd><p>Objective function history.</p>
</dd>
<dt><strong>p</strong><span class="classifier">int</span></dt><dd><p>Number of iterations run.</p>
</dd>
<dt><strong>fpc</strong><span class="classifier">float</span></dt><dd><p>Final fuzzy partition coefficient.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Ross et al. <a class="reference internal" href="#re5bb8c5aa6e3-1" id="id5">[1]</a> did not include a prediction algorithm to go along with
fuzzy c-means. This prediction algorithm works by repeating the clustering
with fixed centers, then efficiently finds the fuzzy membership at all
points.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re5bb8c5aa6e3-1"><span class="brackets"><a class="fn-backref" href="#id5">1</a></span></dt>
<dd><p>Ross, Timothy J. Fuzzy Logic With Engineering Applications, 3rd ed.
Wiley. 2010. ISBN 978-0-470-74376-8 pp 352-353, eq 10.28 - 10.35.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.continuous_to_discrete">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">continuous_to_discrete</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_rate</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/_continuous_to_discrete.html#continuous_to_discrete"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.continuous_to_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a continuous-time system to its equivalent discrete-time version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(N, N) array of floats</span></dt><dd><p>State variable coefficients describing the continuous-time system.</p>
</dd>
<dt><strong>b</strong><span class="classifier">(N,) or (N, 1) array of floats</span></dt><dd><p>Constant coefficients describing the continuous-time system. Can be
either a rank-1 array or a rank-2 array of shape (N, 1).</p>
</dd>
<dt><strong>sampling_rate</strong><span class="classifier">float</span></dt><dd><p>Rate in Hz at which the continuous-time system is to be sampled.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">(N, N) array of floats</span></dt><dd><p>Variable coefficients describing the discrete-time system.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">(N,) or (N, 1) array of floats</span></dt><dd><p>Constant coefficients describing the discrete-time system. Shape of
this output maintains the shape passed as <cite>b</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.contrast">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">contrast</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amount</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#contrast"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.contrast" title="Permalink to this definition">¶</a></dt>
<dd><p>General contrast booster or diffuser of normalized array-like data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>arr</strong><span class="classifier">ndarray</span></dt><dd><p>Input array (of floats on range [0, 1] if <code class="docutils literal notranslate"><span class="pre">normalize=False</span></code>). If
values exist outside this range, with <code class="docutils literal notranslate"><span class="pre">normalize=True</span></code> the image
will be normalized for calculation.</p>
</dd>
<dt><strong>amount</strong><span class="classifier">float or length-2 iterable of floats</span></dt><dd><p>Controls the exponential contrast mechanism for values above and below
<code class="docutils literal notranslate"><span class="pre">split</span></code> in <code class="docutils literal notranslate"><span class="pre">I</span></code>. If positive, the curve provides added contrast;
if negative, the curve provides reduced contrast.</p>
<p>If provided as a lenth-2 iterable of floats, they control the regions
(below, above) <code class="docutils literal notranslate"><span class="pre">split</span></code> separately.</p>
</dd>
<dt><strong>split</strong><span class="classifier">float</span></dt><dd><p>Positive scalar, on range [0, 1], determining the midpoint of the
exponential contrast. Default of 0.5 is reasonable for well-exposed
images.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, default True</span></dt><dd><p>Controls normalization to the range [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>focused</strong><span class="classifier">ndarray</span></dt><dd><p>Contrast adjusted, normalized, floating-point image on range [0, 1].</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.fuzzymath.sigmoid</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The result of this algorithm is like applying a Curves adjustment in the
GIMP or Photoshop.</p>
<p>Algorithm for curves adjustment at a given pixel, x, is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       <span class="o">|</span> <span class="n">split</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">split</span><span class="p">)</span><span class="o">^</span><span class="n">below</span><span class="p">,</span>                        <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">split</span>
<span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span>
       <span class="o">|</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">split</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">split</span><span class="p">))</span><span class="o">^</span><span class="n">above</span><span class="p">,</span>   <span class="n">split</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.dcentroid">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">dcentroid</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/defuzzify/defuzz.html#dcentroid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.dcentroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Defuzzification using a differential centroidal method about <cite>x0</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Fuzzy membership function.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>Central value to calculate differential centroid about.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">1d array</span></dt><dd><p>Defuzzified result.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.defuzzify.defuzz</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.defuzzify.centroid</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.defocus_local_means">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">defocus_local_means</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/image/imops.html#defocus_local_means"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.defocus_local_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Defocusing non-normalized image <code class="docutils literal notranslate"><span class="pre">im</span></code> using local arithmatic mean.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>im</strong><span class="classifier">ndarray</span></dt><dd><p>Input image, normalization not required. NaN values unsupported.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>D</strong><span class="classifier">ndarray of floats, same shape as <code class="docutils literal notranslate"><span class="pre">im</span></code></span></dt><dd><p>Defocused output image. By definition will not extend the range of
<code class="docutils literal notranslate"><span class="pre">im</span></code>, but the result returned will be an array of floats
regardless of input dtype.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Reduces ‘salt &amp; pepper’ noise in a quantized image by taking the
arithmatic mean of the 4-connected neighborhood. So the new value at
<code class="docutils literal notranslate"><span class="pre">X</span></code>, given the 4-connected neighborhood:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+---+</span>
    <span class="o">|</span> <span class="n">c</span> <span class="o">|</span>
<span class="o">+---+---+---+</span>
<span class="o">|</span> <span class="n">a</span> <span class="o">|</span> <span class="n">X</span> <span class="o">|</span> <span class="n">b</span> <span class="o">|</span>
<span class="o">+---+---+---+</span>
    <span class="o">|</span> <span class="n">d</span> <span class="o">|</span>
    <span class="o">+---+</span>
</pre></div>
</div>
<p>is defined by the relationship:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.defuzz">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">defuzz</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/defuzzify/defuzz.html#defuzz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.defuzz" title="Permalink to this definition">¶</a></dt>
<dd><p>Defuzzification of a membership function, returning a defuzzified value
of the function at x, using various defuzzification methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array or iterable, length N</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array of iterable, length N</span></dt><dd><p>Fuzzy membership function.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string</span></dt><dd><p>Controls which defuzzification method will be used.
* ‘centroid’: Centroid of area
* ‘bisector’: bisector of area
* ‘mom’     : mean of maximum
* ‘som’     : min of maximum
* ‘lom’     : max of maximum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">float or int</span></dt><dd><p>Defuzzified result.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>- EmptyMembershipError</strong><span class="classifier">When the membership function area is empty.</span></dt><dd></dd>
<dt><strong>- InconsistentMFDataError</strong><span class="classifier">When the length of the ‘x’ and the fuzzy</span></dt><dd><p>membership function arrays are not equal.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.defuzzify.centroid</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.defuzzify.dcentroid</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.divval">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">divval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#divval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.divval" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide <code class="docutils literal notranslate"><span class="pre">interval2</span></code> into <code class="docutils literal notranslate"><span class="pre">interval1</span></code>, by inversion and multiplication.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>interval1</strong><span class="classifier">2-element iterable</span></dt><dd><p>First interval set.</p>
</dd>
<dt><strong>interval2</strong><span class="classifier">2-element iterable</span></dt><dd><p>Second interval set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">2-element array</span></dt><dd><p>Interval result of interval1 / interval2.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.dsigmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">dsigmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#dsigmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.dsigmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference of two fuzzy sigmoid membership functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>b1</strong><span class="classifier">float</span></dt><dd><p>Midpoint of first sigmoid; f1(b1) = 0.5</p>
</dd>
<dt><strong>c1</strong><span class="classifier">float</span></dt><dd><p>Width and sign of first sigmoid.</p>
</dd>
<dt><strong>b2</strong><span class="classifier">float</span></dt><dd><p>Midpoint of second sigmoid; f2(b2) = 0.5</p>
</dd>
<dt><strong>c2</strong><span class="classifier">float</span></dt><dd><p>Width and sign of second sigmoid.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><dl class="simple">
<dt>Generated sigmoid values, defined as</dt><dd><p>y = f1 - f2
f1(x) = 1 / (1. + exp[- c1 * (x - b1)])
f2(x) = 1 / (1. + exp[- c2 * (x - b2)])</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.dsw_add">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">dsw_add</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#dsw_add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.dsw_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two fuzzy variables together using the restricted DSW method [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Universe for first fuzzy variable.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>. Must be convex.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Universe for second fuzzy variable.</p>
</dd>
<dt><strong>mfy</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>. Must be convex.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of lambda-cuts to use; a higher number will have greater
resolution toward the limit imposed by input sets <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output universe variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Output fuzzy membership on universe <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Dong, Shah, and Wong (DSW) method requires convex fuzzy membership
functions. The <code class="docutils literal notranslate"><span class="pre">dsw_*</span></code> functions return results similar to Matplotlib’s
<code class="docutils literal notranslate"><span class="pre">fuzarith</span></code> function.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r754ebc060329-1"><span class="brackets">1</span></dt>
<dd><p>W. Dong and H. Shah and F. Wong, Fuzzy computations in risk and
decision analysis, Civ Eng Syst, 2, 1985, pp 201-208.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.dsw_div">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">dsw_div</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#dsw_div"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.dsw_div" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide one fuzzy variable by another using the restricted DSW method [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Universe for first fuzzy variable.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>. Must be convex.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Universe for second fuzzy variable.</p>
</dd>
<dt><strong>mfy</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>. Must be convex.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of lambda-cuts to use; a higher number will have greater
resolution toward the limit imposed by input sets <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output universe variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Output fuzzy membership on universe <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Dong, Shah, and Wong (DSW) method requires convex fuzzy membership
functions. The <code class="docutils literal notranslate"><span class="pre">dsw_*</span></code> functions return results similar to Matplotlib’s
<code class="docutils literal notranslate"><span class="pre">fuzarith</span></code> function.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd6244bd091fc-1"><span class="brackets">1</span></dt>
<dd><p>W. Dong and H. Shah and F. Wong, Fuzzy computations in risk and
decision analysis, Civ Eng Syst, 2, 1985, pp 201-208.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.dsw_mult">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">dsw_mult</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#dsw_mult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.dsw_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply two fuzzy variables using the restricted DSW method [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Universe for first fuzzy variable.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>. Must be convex.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Universe for second fuzzy variable.</p>
</dd>
<dt><strong>mfy</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>. Must be convex.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of lambda-cuts to use; a higher number will have greater
resolution toward the limit imposed by input sets <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output universe variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Output fuzzy membership on universe <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Dong, Shah, and Wong (DSW) method requires convex fuzzy membership
functions. The <code class="docutils literal notranslate"><span class="pre">dsw_*</span></code> functions return results similar to Matplotlib’s
<code class="docutils literal notranslate"><span class="pre">fuzarith</span></code> function.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b4c91dcd90a-1"><span class="brackets">1</span></dt>
<dd><p>W. Dong and H. Shah and F. Wong, Fuzzy computations in risk and
decision analysis, Civ Eng Syst, 2, 1985, pp 201-208.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.dsw_sub">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">dsw_sub</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#dsw_sub"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.dsw_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract a fuzzy variable from another by the restricted DSW method [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Universe for first fuzzy variable.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>. Must be convex.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Universe for second fuzzy variable, which will be subtracted from
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>mfy</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>. Must be convex.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of lambda-cuts to use; a higher number will have greater
resolution toward the limit imposed by input sets <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output universe variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Output fuzzy membership on universe <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Dong, Shah, and Wong (DSW) method requires convex fuzzy membership
functions. The <code class="docutils literal notranslate"><span class="pre">dsw_*</span></code> functions return results similar to Matplotlib’s
<code class="docutils literal notranslate"><span class="pre">fuzarith</span></code> function.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r023c1c048742-1"><span class="brackets">1</span></dt>
<dd><p>W. Dong and H. Shah and F. Wong, Fuzzy computations in risk and
decision analysis, Civ Eng Syst, 2, 1985, pp 201-208.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fire1d">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fire1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/filters/fire.html#fire1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fire1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1-D filtering using Fuzzy Inference Ruled by Else-action (FIRE) [1].</p>
<p>FIRE filtering is nonlinear, and is specifically designed to remove
impulse (salt and pepper) noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Input sequence, filtered range limited by <code class="docutils literal notranslate"><span class="pre">l1</span></code> and <code class="docutils literal notranslate"><span class="pre">l2</span></code>.</p>
</dd>
<dt><strong>l1</strong><span class="classifier">float</span></dt><dd><p>Lower input range limit for <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>l2</strong><span class="classifier">float</span></dt><dd><p>Upper input range limit for <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>FIRE filtered sequence.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Filtering occurs for <code class="docutils literal notranslate"><span class="pre">l1</span> <span class="pre">&lt;</span> <span class="pre">|x|</span> <span class="pre">&lt;</span> <span class="pre">l2</span></code>; for <code class="docutils literal notranslate"><span class="pre">|x|</span> <span class="pre">&lt;</span> <span class="pre">l1</span></code> there is no
effect.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1cfc1077e904-1"><span class="brackets">1</span></dt>
<dd><p>Fabrizio Russo, Fuzzy Filtering of Noisy Sensor Data, IEEE
Instrumentation and Measurement Technology Conference,
Brussels, Belgium, June 4 - 6, 1996, pp 1281 - 1285.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fire2d">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fire2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">255</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fuzzyresolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/filters/fire.html#fire2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fire2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2-D filtering using Fuzzy Inference Ruled by Else-action (FIRE) [1].</p>
<p>FIRE filtering is nonlinear, and is specifically designed to remove
impulse (salt and pepper) noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>I</strong><span class="classifier">2d array</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>l1</strong><span class="classifier">float</span></dt><dd><p>Lower limit of filtering range.</p>
</dd>
<dt><strong>l2</strong><span class="classifier">float</span></dt><dd><p>Upper limit of filtering range.</p>
</dd>
<dt><strong>fuzzyresolution</strong><span class="classifier">float, default = 1</span></dt><dd><p>Resolution of fuzzy input sequence, or spacing between [-l2+1, l2-1].
The default assumes an integer input; for floating point images a
decimal value should be used approximately equal to the bit depth.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>J</strong><span class="classifier">2d array</span></dt><dd><p>FIRE filtered image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Filtering occurs for <code class="docutils literal notranslate"><span class="pre">l1</span> <span class="pre">&lt;</span> <span class="pre">|x|</span> <span class="pre">&lt;</span> <span class="pre">l2</span></code>; outside this range the data is
unaffected.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0fb2dcf5bc72-1"><span class="brackets">1</span></dt>
<dd><p>Fabrizio Russo, Fuzzy Filtering of Noisy Sensor Data, IEEE
Instrumentation and Measurement Technology Conference,
Brussels, Belgium, June 4 - 6, 1996, pp 1281 - 1285.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_add">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_add</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#fuzzy_add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code> to fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length N</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt><strong>a</strong><span class="classifier">1d array, length N</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array, length M</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array, length M</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership set for variable <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses Zadeh’s Extension Principle as described in Ross, Fuzzy Logic with
Engineering Applications (2010), pp. 414, Eq. 12.17.</p>
<p>If these results are unexpected and your membership functions are convex,
consider trying the <code class="docutils literal notranslate"><span class="pre">skfuzzy.dsw_*</span></code> functions for fuzzy mathematics
using interval arithmetic via the restricted Dong, Shah, and Wong method.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_and">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_and</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfy</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_logic.html#fuzzy_and"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Fuzzy AND operator, a.k.a. the intersection of two fuzzy sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Universe variable for fuzzy membership function <cite>mfx</cite>.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function for universe variable <cite>x</cite>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Universe variable for fuzzy membership function <cite>mfy</cite>.</p>
</dd>
<dt><strong>mfy</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function for universe variable <cite>y</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Universe variable for union of the two provided fuzzy sets.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy AND (intersection) of <cite>mfx</cite> and <cite>mfy</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_compare">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_compare</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#fuzzy_compare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the comparison matrix, <code class="docutils literal notranslate"><span class="pre">c</span></code>, based on the fuzzy pairwise
comparison matrix, <code class="docutils literal notranslate"><span class="pre">q</span></code>, using Shimura’s special relativity formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">2d array, (N, N)</span></dt><dd><p>Fuzzy pairwise comparison matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>c</strong><span class="classifier">2d array, (N, N)</span></dt><dd><p>Comparison matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_div">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_div</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#fuzzy_div"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_div" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code> into fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length N</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt><strong>a</strong><span class="classifier">1d array, length N</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array, length M (excluding zero array)</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array, length M</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership set for variable z.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses Zadeh’s Extension Principle from Ross, Fuzzy Logic w/Engineering
Applications, (2010), pp.414, Eq. 12.17.</p>
<p>If these results are unexpected and your membership functions are convex,
consider trying the <code class="docutils literal notranslate"><span class="pre">skfuzzy.dsw_*</span></code> functions for fuzzy mathematics
using interval arithmetic via the restricted Dong, Shah, and Wong method.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_min">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_min</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#fuzzy_min"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Find minimum between fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code> fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length N</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt><strong>a</strong><span class="classifier">1d array, length N</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array, length M</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array, length M</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership set for variable z.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses Zadeh’s Extension Principle from Ross, Fuzzy Logic w/Engineering
Applications, (2010), pp.414, Eq. 12.17.</p>
<p>If these results are unexpected and your membership functions are convex,
consider trying the <code class="docutils literal notranslate"><span class="pre">skfuzzy.dsw_*</span></code> functions for fuzzy mathematics
using interval arithmetic via the restricted Dong, Shah, and Wong method.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_mult">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_mult</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#fuzzy_mult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code> and fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length N</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt><strong>A</strong><span class="classifier">1d array, length N</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array, length M</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array, length M</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership set for variable z.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses Zadeh’s Extension Principle from Ross, Fuzzy Logic w/Engineering
Applications, (2010), pp.414, Eq. 12.17.</p>
<p>If these results are unexpected and your membership functions are convex,
consider trying the <code class="docutils literal notranslate"><span class="pre">skfuzzy.dsw_*</span></code> functions for fuzzy mathematics
using interval arithmetic via the restricted Dong, Shah, and Wong method.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_not">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_not</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_logic.html#fuzzy_not"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Fuzzy NOT operator, a.k.a. complement of a fuzzy set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy NOT (complement) of <cite>mfx</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This operation does not require a universe variable, because the
complement is defined for a single set. The output remains defined on the
same universe.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_or">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_or</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfy</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_logic.html#fuzzy_or"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Fuzzy OR operator, a.k.a. union of two fuzzy sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Universe variable for fuzzy membership function <cite>mfx</cite>.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function for universe variable <cite>x</cite>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Universe variable for fuzzy membership function <cite>mfy</cite>.</p>
</dd>
<dt><strong>mfy</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function for universe variable <cite>y</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Universe variable for intersection of the two provided fuzzy sets.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy OR (union) of <cite>mfx</cite> and <cite>mfy</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_similarity">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_similarity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ai</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'min'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#fuzzy_similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>The fuzzy similarity between set <code class="docutils literal notranslate"><span class="pre">ai</span></code> and observation set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ai</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function of set <code class="docutils literal notranslate"><span class="pre">ai</span></code>.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function of set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string</span></dt><dd><p>Controls the method of similarity calculation.
* <code class="docutils literal notranslate"><span class="pre">'min'</span></code> : Computed by array minimum operation.
* <code class="docutils literal notranslate"><span class="pre">'avg'</span></code> : Computed by taking the array average.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>s</strong><span class="classifier">float</span></dt><dd><p>Fuzzy similarity.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.fuzzy_sub">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">fuzzy_sub</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#fuzzy_sub"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.fuzzy_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code> from fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length N</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt><strong>A</strong><span class="classifier">1d array, length N</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">1d array, length M</span></dt><dd><p>Universe variable for fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array, length M</span></dt><dd><p>Fuzzy set for universe <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array</span></dt><dd><p>Output variable.</p>
</dd>
<dt><strong>mfz</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership set for variable z.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses Zadeh’s Extension Principle from Ross, Fuzzy Logic w/Engineering
Applications, (2010), pp.414, Eq. 12.17.</p>
<p>If these results are unexpected and your membership functions are convex,
consider trying the <code class="docutils literal notranslate"><span class="pre">skfuzzy.dsw_*</span></code> functions for fuzzy mathematics
using interval arithmetic via the restricted Dong, Shah, and Wong method.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.gauss2mf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">gauss2mf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#gauss2mf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.gauss2mf" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian fuzzy membership function of two combined Gaussians.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>mean1</strong><span class="classifier">float</span></dt><dd><p>Gaussian parameter for center (mean) value of left-side Gaussian.
Note mean1 &lt;= mean2 reqiured.</p>
</dd>
<dt><strong>sigma1</strong><span class="classifier">float</span></dt><dd><p>Standard deviation of left Gaussian.</p>
</dd>
<dt><strong>mean2</strong><span class="classifier">float</span></dt><dd><p>Gaussian parameter for center (mean) value of right-side Gaussian.
Note mean2 &gt;= mean1 required.</p>
</dd>
<dt><strong>sigma2</strong><span class="classifier">float</span></dt><dd><p>Standard deviation of right Gaussian.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Membership function with left side up to <cite>mean1</cite> defined by the first
Gaussian, and the right side above <cite>mean2</cite> defined by the second.
In the range mean1 &lt;= x &lt;= mean2 the function has value = 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.gaussmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">gaussmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#gaussmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.gaussmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian fuzzy membership function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float</span></dt><dd><p>Gaussian parameter for center (mean) value.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float</span></dt><dd><p>Gaussian parameter for standard deviation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Gaussian membership function for x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.gbellmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">gbellmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#gbellmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.gbellmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized Bell function fuzzy membership generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>a</strong><span class="classifier">float</span></dt><dd><p>Bell function parameter controlling width. See Note for definition.</p>
</dd>
<dt><strong>b</strong><span class="classifier">float</span></dt><dd><p>Bell function parameter controlling slope. See Note for definition.</p>
</dd>
<dt><strong>c</strong><span class="classifier">float</span></dt><dd><p>Bell function parameter defining the center. See Note for definition.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Generalized Bell fuzzy membership function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Definition of Generalized Bell function is:</p>
<blockquote>
<div><p>y(x) = 1 / (1 + abs([x - c] / a) ** [2 * b])</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.inner_product">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">inner_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.inner_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (dot product) of two fuzzy sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Fuzzy membership function.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Fuzzy membership function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">float</span></dt><dd><p>Fuzzy inner product value, on range [0, 1]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.interp10">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">interp10</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#interp10"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.interp10" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function which conducts linear interpolation of any rank-1 array.
Result will have 10x resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length N</span></dt><dd><p>Input array to be interpolated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array, length 10 * N + 1</span></dt><dd><p>Linearly interpolated output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.interp_membership">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">interp_membership</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_outside_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#interp_membership"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.interp_membership" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the degree of membership <code class="docutils literal notranslate"><span class="pre">u(xx)</span></code> for a given value of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">xx</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent discrete variable vector.</p>
</dd>
<dt><strong>xmf</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function for <code class="docutils literal notranslate"><span class="pre">x</span></code>.  Same length as <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>xx</strong><span class="classifier">float or array of floats</span></dt><dd><p>Value(s) on universe <code class="docutils literal notranslate"><span class="pre">x</span></code> where the interpolated membership is
desired.</p>
</dd>
<dt><strong>zero_outside_x</strong><span class="classifier">bool, optional</span></dt><dd><p>Defines the behavior if <code class="docutils literal notranslate"><span class="pre">xx</span></code> contains value(s) which are outside the
universe range as defined by <code class="docutils literal notranslate"><span class="pre">x</span></code>.  If <cite>True</cite> (default), all
extrapolated values will be zero.  If <cite>False</cite>, the first or last value
in <code class="docutils literal notranslate"><span class="pre">x</span></code> will be what is returned to the left or right of the range,
respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xxmf</strong><span class="classifier">float or array of floats</span></dt><dd><p>Membership function value at <code class="docutils literal notranslate"><span class="pre">xx</span></code>, <code class="docutils literal notranslate"><span class="pre">u(xx)</span></code>.  If <code class="docutils literal notranslate"><span class="pre">xx</span></code> is a single
value, this will be a single value; if it is an array or iterable the
result will be returned as a NumPy array of like shape.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For use in Fuzzy Logic, where an interpolated discrete membership function
u(x) for discrete values of x on the universe of <code class="docutils literal notranslate"><span class="pre">x</span></code> is given. Then,
consider a new value x = xx, which does not correspond to any discrete
values of <code class="docutils literal notranslate"><span class="pre">x</span></code>. This function computes the membership value <code class="docutils literal notranslate"><span class="pre">u(xx)</span></code>
corresponding to the value <code class="docutils literal notranslate"><span class="pre">xx</span></code> using linear interpolation.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.interp_universe">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">interp_universe</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#interp_universe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.interp_universe" title="Permalink to this definition">¶</a></dt>
<dd><p>Find interpolated universe value(s) for a given fuzzy membership value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent discrete variable vector.</p>
</dd>
<dt><strong>xmf</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function for <code class="docutils literal notranslate"><span class="pre">x</span></code>.  Same length as <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">float</span></dt><dd><p>Specific fuzzy membership value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xx</strong><span class="classifier">list</span></dt><dd><p>List of discrete singleton values on universe <code class="docutils literal notranslate"><span class="pre">x</span></code> whose
membership function value is y, <code class="docutils literal notranslate"><span class="pre">u(xx[i])==y</span></code>.
If there are not points xx[i] such that <code class="docutils literal notranslate"><span class="pre">u(xx[i])==y</span></code>
it returns an empty list.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For use in Fuzzy Logic, where a membership function level <code class="docutils literal notranslate"><span class="pre">y</span></code> is given.
Consider there is some value (or set of values) <code class="docutils literal notranslate"><span class="pre">xx</span></code> for which
<code class="docutils literal notranslate"><span class="pre">u(xx)</span> <span class="pre">==</span> <span class="pre">y</span></code> is true, though <code class="docutils literal notranslate"><span class="pre">xx</span></code> may not correspond to any discrete
values on <code class="docutils literal notranslate"><span class="pre">x</span></code>. This function computes the value (or values) of <code class="docutils literal notranslate"><span class="pre">xx</span></code>
such that <code class="docutils literal notranslate"><span class="pre">u(xx)</span> <span class="pre">==</span> <span class="pre">y</span></code> using linear interpolation.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.lambda_cut">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">lambda_cut</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/defuzzify/defuzz.html#lambda_cut"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.lambda_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>The crisp (binary) lambda-cut set of the membership sequence <cite>ms</cite>
with membership &gt;= <cite>lcut</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ms</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership set.</p>
</dd>
<dt><strong>lcut</strong><span class="classifier">float</span></dt><dd><p>Value used for lambda-cut, on range [0, 1.0].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mlambda</strong><span class="classifier">1d array</span></dt><dd><p>Lambda-cut set of <cite>ms</cite>: ones if ms[i] &gt;= lcut, zeros otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.lambda_cut_boundaries">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">lambda_cut_boundaries</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdacut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/defuzzify/defuzz.html#lambda_cut_boundaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.lambda_cut_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Find exact boundaries where <cite>mfx</cite> crosses <cite>lambdacut</cite> using interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array, length N</span></dt><dd><p>Universe variable</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array, length N</span></dt><dd><p>Fuzzy membership function</p>
</dd>
<dt><strong>lambdacut</strong><span class="classifier">float</span></dt><dd><p>Floating point value on range [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>boundaries</strong><span class="classifier">1d array</span></dt><dd><p>Floating point values of <cite>x</cite> where <cite>mfx</cite> crosses <cite>lambdacut</cite>.
Calculated using linear interpolation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The values returned by this function can be thought of as intersections
between a hypothetical horizontal line at <code class="docutils literal notranslate"><span class="pre">lambdacut</span></code> and the membership
function <code class="docutils literal notranslate"><span class="pre">mfx</span></code>. This function assumes the end values of <code class="docutils literal notranslate"><span class="pre">mfx</span></code> continue
on forever in positive and negative directions. This means there will NOT
be crossings found exactly at the bounds of <code class="docutils literal notranslate"><span class="pre">x</span></code> unless the value of
<code class="docutils literal notranslate"><span class="pre">mfx</span></code> at the boundary is exactly <code class="docutils literal notranslate"><span class="pre">lambdacut</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.lambda_cut_series">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">lambda_cut_series</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mfx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/defuzzify/defuzz.html#lambda_cut_series"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.lambda_cut_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine a series of lambda-cuts in a sweep from 0+ to 1.0 in n steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Universe function for fuzzy membership function mfx.</p>
</dd>
<dt><strong>mfx</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy membership function for x.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of steps.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">2d array, (n, 3)</span></dt><dd><p>Lambda cut intevals.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.maxmin_composition">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">maxmin_composition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#maxmin_composition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.maxmin_composition" title="Permalink to this definition">¶</a></dt>
<dd><p>The max-min composition <code class="docutils literal notranslate"><span class="pre">t</span></code> of two fuzzy relation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">2d array, (M, N)</span></dt><dd><p>Fuzzy relation matrix #1.</p>
</dd>
<dt><strong>r</strong><span class="classifier">2d array, (N, P)</span></dt><dd><p>Fuzzy relation matrix #2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>T ; 2d array, (M, P)</dt><dd><p>Max-min composition, defined by <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">o</span> <span class="pre">r</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.maxprod_composition">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">maxprod_composition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#maxprod_composition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.maxprod_composition" title="Permalink to this definition">¶</a></dt>
<dd><p>The max-product composition <code class="docutils literal notranslate"><span class="pre">t</span></code> of two fuzzy relation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">2d array, (M, N)</span></dt><dd><p>Fuzzy relation matrix #1.</p>
</dd>
<dt><strong>r</strong><span class="classifier">2d array, (N, P)</span></dt><dd><p>Fuzzy relation matrix #2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t</strong><span class="classifier">2d array, (M, P)</span></dt><dd><p>Max-product composition matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.modus_ponens">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">modus_ponens</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#modus_ponens"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.modus_ponens" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized <em>modus ponens</em> deduction to make approximate reasoning in a
rules-base system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy set <code class="docutils literal notranslate"><span class="pre">a</span></code> on universe <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy set <code class="docutils literal notranslate"><span class="pre">b</span></code> on universe <code class="docutils literal notranslate"><span class="pre">y</span></code></p>
</dd>
<dt><strong>ap</strong><span class="classifier">1d array</span></dt><dd><p>New fuzzy fact a’ (a prime, not transpose)</p>
</dd>
<dt><strong>c</strong><span class="classifier">1d array, OPTIONAL</span></dt><dd><p>Keyword argument representing fuzzy set <code class="docutils literal notranslate"><span class="pre">c</span></code> on universe <code class="docutils literal notranslate"><span class="pre">y</span></code>.
Default = None, which will use <code class="docutils literal notranslate"><span class="pre">np.ones()</span></code> instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">2d array</span></dt><dd><p>Full fuzzy relation.</p>
</dd>
<dt><strong>bp</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy conclusion b’ (b prime)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.multval">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">multval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#multval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.multval" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply intervals interval1 and interval2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>interval1</strong><span class="classifier">1d array, length 2</span></dt><dd><p>First interval.</p>
</dd>
<dt><strong>interval2</strong><span class="classifier">1d array, length 2</span></dt><dd><p>Second interval.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array, length 2</span></dt><dd><p>Interval resulting from multiplication of interval1 and interval2.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.nmse">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">nmse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">known</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degraded</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/image/metrics.html#nmse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.nmse" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the percent normalized mean square error (NMSE %) between known
and degraded arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>known</strong><span class="classifier">ndarray</span></dt><dd><p>Known array of arbitrary size and shape. Must be convertible to float.</p>
</dd>
<dt><strong>degraded</strong><span class="classifier">ndarray, same shape as <cite>known</cite></span></dt><dd><p>Degraded version of <cite>known</cite>, must have same shape as <cite>known</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nmse</strong><span class="classifier">float</span></dt><dd><p>Calculated NMSE, as a percentage.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Usually used to compare a true/original image to a degraded version.
For this calculation, which image is provided as true and which degraded
does not matter.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.outer_product">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">outer_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#outer_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.outer_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Outer product of two fuzzy sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Fuzzy membership function.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array or iterable</span></dt><dd><p>Fuzzy membership function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">float</span></dt><dd><p>Fuzzy outer product value, on range [0, 1]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.pad">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">pad</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skfuzzy.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad an array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>array</strong><span class="classifier">array_like of rank N</span></dt><dd><p>The array to pad.</p>
</dd>
<dt><strong>pad_width</strong><span class="classifier">{sequence, array_like, int}</span></dt><dd><p>Number of values padded to the edges of each axis.
((before_1, after_1), … (before_N, after_N)) unique pad widths
for each axis.
((before, after),) yields same before and after pad for each axis.
(pad,) or int is a shortcut for before = after = pad width for all
axes.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or function, optional</span></dt><dd><p>One of the following string values or a user supplied function.</p>
<dl>
<dt>‘constant’ (default)</dt><dd><p>Pads with a constant value.</p>
</dd>
<dt>‘edge’</dt><dd><p>Pads with the edge values of array.</p>
</dd>
<dt>‘linear_ramp’</dt><dd><p>Pads with the linear ramp between end_value and the
array edge value.</p>
</dd>
<dt>‘maximum’</dt><dd><p>Pads with the maximum value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘mean’</dt><dd><p>Pads with the mean value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘median’</dt><dd><p>Pads with the median value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘minimum’</dt><dd><p>Pads with the minimum value of all or part of the
vector along each axis.</p>
</dd>
<dt>‘reflect’</dt><dd><p>Pads with the reflection of the vector mirrored on
the first and last values of the vector along each
axis.</p>
</dd>
<dt>‘symmetric’</dt><dd><p>Pads with the reflection of the vector mirrored
along the edge of the array.</p>
</dd>
<dt>‘wrap’</dt><dd><p>Pads with the wrap of the vector along the axis.
The first values are used to pad the end and the
end values are used to pad the beginning.</p>
</dd>
<dt>‘empty’</dt><dd><p>Pads with undefined values.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.17.</span></p>
</div>
</dd>
<dt>&lt;function&gt;</dt><dd><p>Padding function, see Notes.</p>
</dd>
</dl>
</dd>
<dt><strong>stat_length</strong><span class="classifier">sequence or int, optional</span></dt><dd><p>Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’.  Number of
values at edge of each axis used to calculate the statistic value.</p>
<p>((before_1, after_1), … (before_N, after_N)) unique statistic
lengths for each axis.</p>
<p>((before, after),) yields same before and after statistic lengths
for each axis.</p>
<p>(stat_length,) or int is a shortcut for before = after = statistic
length for all axes.</p>
<p>Default is <code class="docutils literal notranslate"><span class="pre">None</span></code>, to use the entire axis.</p>
</dd>
<dt><strong>constant_values</strong><span class="classifier">sequence or scalar, optional</span></dt><dd><p>Used in ‘constant’.  The values to set the padded values for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span> <span class="pre">...</span> <span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> unique pad constants
for each axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span></code> yields same before and after constants for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">(constant,)</span></code> or <code class="docutils literal notranslate"><span class="pre">constant</span></code> is a shortcut for <code class="docutils literal notranslate"><span class="pre">before</span> <span class="pre">=</span> <span class="pre">after</span> <span class="pre">=</span> <span class="pre">constant</span></code> for
all axes.</p>
<p>Default is 0.</p>
</dd>
<dt><strong>end_values</strong><span class="classifier">sequence or scalar, optional</span></dt><dd><p>Used in ‘linear_ramp’.  The values used for the ending value of the
linear_ramp and that will form the edge of the padded array.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span> <span class="pre">...</span> <span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> unique end values
for each axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span></code> yields same before and after end values for each
axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">(constant,)</span></code> or <code class="docutils literal notranslate"><span class="pre">constant</span></code> is a shortcut for <code class="docutils literal notranslate"><span class="pre">before</span> <span class="pre">=</span> <span class="pre">after</span> <span class="pre">=</span> <span class="pre">constant</span></code> for
all axes.</p>
<p>Default is 0.</p>
</dd>
<dt><strong>reflect_type</strong><span class="classifier">{‘even’, ‘odd’}, optional</span></dt><dd><p>Used in ‘reflect’, and ‘symmetric’.  The ‘even’ style is the
default with an unaltered reflection around the edge value.  For
the ‘odd’ style, the extended part of the array is created by
subtracting the reflected values from two times the edge value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pad</strong><span class="classifier">ndarray</span></dt><dd><p>Padded array of rank equal to <cite>array</cite> with shape increased
according to <cite>pad_width</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.</p>
<p>The padding function, if used, should modify a rank 1 array in-place. It
has the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">padding_func</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">iaxis_pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<blockquote>
<div><dl class="simple">
<dt>vector<span class="classifier">ndarray</span></dt><dd><p>A rank 1 array already padded with zeros.  Padded values are
vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].</p>
</dd>
<dt>iaxis_pad_width<span class="classifier">tuple</span></dt><dd><p>A 2-tuple of ints, iaxis_pad_width[0] represents the number of
values padded at the beginning of vector where
iaxis_pad_width[1] represents the number of values padded at
the end of vector.</p>
</dd>
<dt>iaxis<span class="classifier">int</span></dt><dd><p>The axis currently being calculated.</p>
</dd>
<dt>kwargs<span class="classifier">dict</span></dt><dd><p>Any keyword arguments the function requires.</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">array([4, 4, 1, ..., 6, 6, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">array([1, 1, 1, ..., 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;linear_ramp&#39;</span><span class="p">,</span> <span class="n">end_values</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;maximum&#39;</span><span class="p">)</span>
<span class="go">array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;median&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s1">&#39;minimum&#39;</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [3, 3, 3, 4, 3, 3, 3],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
<span class="go">array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pad_with</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">pad_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;padder&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[:</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">)</span>
<span class="go">array([[10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10,  0,  1,  2, 10, 10],</span>
<span class="go">       [10, 10,  3,  4,  5, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">,</span> <span class="n">padder</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">array([[100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100,   0,   1,   2, 100, 100],</span>
<span class="go">       [100, 100,   3,   4,   5, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.partial_dmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">partial_dmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mf_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mf_parameter_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_parameter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#partial_dmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.partial_dmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the <em>partial derivative</em> of a specified membership function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">float</span></dt><dd><p>input variable.</p>
</dd>
<dt><strong>mf_name</strong><span class="classifier">string</span></dt><dd><p>Membership function name as a string. The following are supported:
* <code class="docutils literal notranslate"><span class="pre">'gaussmf'</span></code> : parameters <code class="docutils literal notranslate"><span class="pre">'sigma'</span></code> or <code class="docutils literal notranslate"><span class="pre">'mean'</span></code>
* <code class="docutils literal notranslate"><span class="pre">'gbellmf'</span></code> : parameters <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'c'</span></code>
* <code class="docutils literal notranslate"><span class="pre">'sigmf'</span></code> : parameters <code class="docutils literal notranslate"><span class="pre">'b'</span></code> or <code class="docutils literal notranslate"><span class="pre">'c'</span></code></p>
</dd>
<dt><strong>mf_parameter_dict</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of <code class="docutils literal notranslate"><span class="pre">{param</span> <span class="pre">:</span> <span class="pre">key-value,</span> <span class="pre">...}</span></code> pairs for a particular
membership function as defined above.</p>
</dd>
<dt><strong>partial_parameter</strong><span class="classifier">string</span></dt><dd><p>Name of the parameter against which we take the partial derivative.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">float</span></dt><dd><p>Partial derivative of the membership function with respect to the
chosen parameter, at input point <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Partial derivatives of fuzzy membership functions are only meaningful for
continuous functions. Triangular, trapezoidal designs have no partial
derivatives to calculate. The following</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.piecemf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">piecemf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#piecemf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.piecemf" title="Permalink to this definition">¶</a></dt>
<dd><p>Piecewise linear membership function (particularly used in FIRE filters).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable vector.</p>
</dd>
<dt><strong>abc</strong><span class="classifier">1d array, length 3</span></dt><dd><p>Defines the piecewise function. Important: if abc = [a, b, c] then
a &lt;= b &lt;= c is REQUIRED!</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Piecewise fuzzy membership function for x.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Piecewise definition:</dt><dd><p>y = 0,                    min(x) &lt;= x &lt;= a
y = b(x - a)/c(b - a),    a &lt;= x &lt;= b
y = x/c,                  b &lt;= x &lt;= c</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.pimf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">pimf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#pimf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.pimf" title="Permalink to this definition">¶</a></dt>
<dd><p>Pi-function fuzzy membership generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>a</strong><span class="classifier">float</span></dt><dd><p>Left ‘foot’, where the function begins to climb from zero.</p>
</dd>
<dt><strong>b</strong><span class="classifier">float</span></dt><dd><p>Left ‘ceiling’, where the function levels off at 1.</p>
</dd>
<dt><strong>c</strong><span class="classifier">float</span></dt><dd><p>Right ‘ceiling’, where the function begins falling from 1.</p>
</dd>
<dt><strong>d</strong><span class="classifier">float</span></dt><dd><p>Right ‘foot’, where the function reattains zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Pi-function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is equivalently a product of smf and zmf.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.psigmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">psigmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#psigmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.psigmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Product of two sigmoid membership functions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Data vector for independent variable.</p>
</dd>
<dt><strong>b1</strong><span class="classifier">float</span></dt><dd><p>Offset or bias for the first sigmoid.  This is the center value of the
sigmoid, where it equals 1/2.</p>
</dd>
<dt><strong>c1</strong><span class="classifier">float</span></dt><dd><p>Controls ‘width’ of the first sigmoidal region about <cite>b1</cite> (magnitude),
and also which side of the function is open (sign). A positive value of
<cite>c1</cite> means the left side approaches zero while the right side
approaches one; a negative value of <cite>c1</cite> means the opposite.</p>
</dd>
<dt><strong>b2</strong><span class="classifier">float</span></dt><dd><p>Offset or bias for the second sigmoid.  This is the center value of the
sigmoid, where it equals 1/2.</p>
</dd>
<dt><strong>c2</strong><span class="classifier">float</span></dt><dd><p>Controls ‘width’ of the second sigmoidal region about <cite>b2</cite> (magnitude),
and also which side of the function is open (sign). A positive value of
<cite>c2</cite> means the left side approaches zero while the right side
approaches one; a negative value of <cite>c2</cite> means the opposite.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Generated sigmoid values, defined as</p>
<p>y = f1(x) * f2(x)</p>
<blockquote>
<div><p>f1(x) = 1 / (1. + exp[- c1 * (x - b1)])
f2(x) = 1 / (1. + exp[- c2 * (x - b2)])</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For a smoothed rect-like function, c2 &lt; 0 &lt; c1. For its inverse (zero in
middle, one at edges) c1 &lt; 0 &lt; c2.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.relation_min">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">relation_min</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#relation_min"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.relation_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine fuzzy relation matrix <code class="docutils literal notranslate"><span class="pre">R</span></code> using Mamdani implication for the
fuzzy antecedent <code class="docutils literal notranslate"><span class="pre">a</span></code> and consequent <code class="docutils literal notranslate"><span class="pre">b</span></code> inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy antecedent variable of length M.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy consequent variable of length N.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">2d array</span></dt><dd><p>Fuzzy relation between <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, of shape (M, N).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.relation_product">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">relation_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#relation_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.relation_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the fuzzy relation matrix, <code class="docutils literal notranslate"><span class="pre">R</span></code>, using product implication for
the fuzzy antecedent <code class="docutils literal notranslate"><span class="pre">a</span></code> and the fuzzy consequent <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy antecedent variable of length M.</p>
</dd>
<dt><strong>b</strong><span class="classifier">1d array</span></dt><dd><p>Fuzzy consequent variable of length N.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">2d array</span></dt><dd><p>Fuzzy relation between <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, of shape (M, N).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.scaleval">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">scaleval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#scaleval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.scaleval" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply scalar q with interval <code class="docutils literal notranslate"><span class="pre">interval</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">float</span></dt><dd><p>Scalar to multiply interval with.</p>
</dd>
<dt><strong>interval</strong><span class="classifier">1d array, length 2</span></dt><dd><p>Interval. Must have exactly two elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z</strong><span class="classifier">1d array, length 2</span></dt><dd><p>New interval; z = q x interval.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.sigmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">sigmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#sigmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.sigmf" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic sigmoid membership function generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Data vector for independent variable.</p>
</dd>
<dt><strong>b</strong><span class="classifier">float</span></dt><dd><p>Offset or bias.  This is the center value of the sigmoid, where it
equals 1/2.</p>
</dd>
<dt><strong>c</strong><span class="classifier">float</span></dt><dd><p>Controls ‘width’ of the sigmoidal region about <cite>b</cite> (magnitude); also
which side of the function is open (sign). A positive value of <cite>a</cite>
means the left side approaches 0.0 while the right side approaches 1.;
a negative value of <cite>c</cite> means the opposite.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Generated sigmoid values, defined as y = 1 / (1. + exp[- c * (x - b)])</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>These are the same values, provided separately and in the opposite order
compared to the publicly available MathWorks’ Fuzzy Logic Toolbox
documentation. Pay close attention to above docstring!</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.sigmoid">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">sigmoid</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/fuzzymath/fuzzy_ops.html#sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Intensify grayscale values in an array using a sigmoid function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Input vector or image array. Should be pre-normalized to range [0, 1]</p>
</dd>
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>Power of the intensification (p &gt; 0). Experiment with small, decimal
values and increase as necessary.</p>
</dd>
<dt><strong>split</strong><span class="classifier">float</span></dt><dd><p>Threshold for intensification. Values above <code class="docutils literal notranslate"><span class="pre">split</span></code> will be
intensified, while values below <cite>split</cite> will be deintensified. Note
range for <code class="docutils literal notranslate"><span class="pre">split</span></code> is (0, 1). Default of 0.5 is reasonable for many
well-exposed images.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray, same size as x</span></dt><dd><p>Output vector or image with contrast adjusted.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skfuzzy.fuzzymath.contrast</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The sigmoid used herein is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">power</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">split</span><span class="p">))))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.smf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">smf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#smf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.smf" title="Permalink to this definition">¶</a></dt>
<dd><p>S-function fuzzy membership generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>a</strong><span class="classifier">float</span></dt><dd><p>‘foot’, where the function begins to climb from zero.</p>
</dd>
<dt><strong>b</strong><span class="classifier">float</span></dt><dd><p>‘ceiling’, where the function levels off at 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>S-function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Named such because of its S-like shape.</p>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.subval">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">subval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/intervals/intervalops.html#subval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.subval" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract interval interval2 from interval interval1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>interval1</strong><span class="classifier">1d array, length 2</span></dt><dd><p>First interval.</p>
</dd>
<dt><strong>interval2</strong><span class="classifier">1d array, length 2</span></dt><dd><p>Second interval.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Z</strong><span class="classifier">1d array, length 2</span></dt><dd><p>Resultant subtracted interval.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.trapmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">trapmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abcd</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#trapmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.trapmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Trapezoidal membership function generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>abcd</strong><span class="classifier">1d array, length 4</span></dt><dd><p>Four-element vector.  Ensure a &lt;= b &lt;= c &lt;= d.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Trapezoidal membership function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.trimf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">trimf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#trimf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.trimf" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular membership function generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>abc</strong><span class="classifier">1d array, length 3</span></dt><dd><p>Three-element vector controlling shape of triangular function.
Requires a &lt;= b &lt;= c.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Triangular membership function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.view_as_blocks">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">view_as_blocks</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/image/shape.html#view_as_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.view_as_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Block view of the input n-dimensional array (using re-striding).</p>
<p>Blocks are non-overlapping views of the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr_in: ndarray</strong></dt><dd><p>The n-dimensional input array.</p>
</dd>
<dt><strong>block_shape: tuple</strong></dt><dd><p>The shape of the block. Each dimension must divide evenly into the
corresponding dimensions of <cite>arr_in</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>arr_out: ndarray</dt><dd><p>Block view of the input array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skfuzzy</span> <span class="kn">import</span> <span class="n">view_as_blocks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_blocks</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">block_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[2, 3],</span>
<span class="go">       [6, 7]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">13</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>  
<span class="go">array([[[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">        [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">        [12, 13, 14, 15, 16, 17],</span>
<span class="go">        [18, 19, 20, 21, 22, 23]],</span>
<span class="go">       [[24, 25, 26, 27, 28, 29],</span>
<span class="go">        [30, 31, 32, 33, 34, 35],</span>
<span class="go">        [36, 37, 38, 39, 40, 41],</span>
<span class="go">        [42, 43, 44, 45, 46, 47]],</span>
<span class="go">       [[48, 49, 50, 51, 52, 53],</span>
<span class="go">        [54, 55, 56, 57, 58, 59],</span>
<span class="go">        [60, 61, 62, 63, 64, 65],</span>
<span class="go">        [66, 67, 68, 69, 70, 71]],</span>
<span class="go">       [[72, 73, 74, 75, 76, 77],</span>
<span class="go">        [78, 79, 80, 81, 82, 83],</span>
<span class="go">        [84, 85, 86, 87, 88, 89],</span>
<span class="go">        [90, 91, 92, 93, 94, 95]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_blocks</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">block_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 2, 3, 1, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">array([[[[52, 53],</span>
<span class="go">         [58, 59]]],</span>
<span class="go">       [[[76, 77],</span>
<span class="go">         [82, 83]]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.view_as_windows">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">view_as_windows</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/image/shape.html#view_as_windows"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.view_as_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolling window view of the input n-dimensional array.</p>
<p>Windows are overlapping views of the input array, with adjacent windows
shifted by a single row or column (or an index of a higher dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr_in: ndarray</strong></dt><dd><p>The n-dimensional input array.</p>
</dd>
<dt><strong>window_shape: tuple</strong></dt><dd><p>Defines the shape of the elementary n-dimensional orthotope
(better know as hyperrectangle <a class="reference internal" href="#r5fa0e8abac4e-1" id="id13">[1]</a>) of the rolling window view.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>arr_out: ndarray</dt><dd><p>(rolling) window view of the input array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>One should be very careful with rolling views when it comes to
memory usage.  Indeed, although a ‘view’ has the same memory
footprint as its base array, the actual array that emerges when this
‘view’ is used in a computation is generally a (much) larger array
than the original, especially for 2-dimensional arrays and above.</p>
<p>For example, let us consider a 3 dimensional array of size (100,
100, 100) of <code class="docutils literal notranslate"><span class="pre">float64</span></code>. This array takes about 8*100**3 Bytes for
storage which is just 8 MB. If one decides to build a rolling view
on this array with a window of (3, 3, 3) the hypothetical size of
the rolling view (if one was to reshape the view for example) would
be 8*(100-3+1)**3*3**3 which is about 203 MB! The scaling becomes
even worse as the dimension of the input array becomes larger.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5fa0e8abac4e-1"><span class="brackets"><a class="fn-backref" href="#id13">1</a></span></dt>
<dd><p><a class="reference external" href="http://en.wikipedia.org/wiki/Hyperrectangle">http://en.wikipedia.org/wiki/Hyperrectangle</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skfuzzy</span> <span class="kn">import</span> <span class="n">view_as_windows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(8, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [2, 3, 4],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [5, 6, 7],</span>
<span class="go">       [6, 7, 8],</span>
<span class="go">       [7, 8, 9]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15],</span>
<span class="go">       [16, 17, 18, 19]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>  
<span class="go">array([[[[ 0,  1,  2],</span>
<span class="go">         [ 4,  5,  6],</span>
<span class="go">         [ 8,  9, 10],</span>
<span class="go">         [12, 13, 14]],</span>
<span class="go">        [[ 1,  2,  3],</span>
<span class="go">         [ 5,  6,  7],</span>
<span class="go">         [ 9, 10, 11],</span>
<span class="go">         [13, 14, 15]]],</span>
<span class="go">       [[[ 4,  5,  6],</span>
<span class="go">         [ 8,  9, 10],</span>
<span class="go">         [12, 13, 14],</span>
<span class="go">         [16, 17, 18]],</span>
<span class="go">        [[ 5,  6,  7],</span>
<span class="go">         [ 9, 10, 11],</span>
<span class="go">         [13, 14, 15],</span>
<span class="go">         [17, 18, 19]]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="skfuzzy.zmf">
<code class="sig-prename descclassname"><span class="pre">skfuzzy.</span></code><code class="sig-name descname"><span class="pre">zmf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skfuzzy/membership/generatemf.html#zmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skfuzzy.zmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Z-function fuzzy membership generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d array</span></dt><dd><p>Independent variable.</p>
</dd>
<dt><strong>a</strong><span class="classifier">float</span></dt><dd><p>‘ceiling’, where the function begins falling from 1.</p>
</dd>
<dt><strong>b</strong><span class="classifier">float</span></dt><dd><p>‘foot’, where the function reattains zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">1d array</span></dt><dd><p>Z-function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Named such because of its Z-like shape.</p>
</dd></dl>

</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
    <h4 class="sidebar-box-heading">Previous topic</h4>
    <div class="well sidebar-box">
        <ul class="nav nav-list">
            <li><a href="../overview.html" title="previous chapter">SciKit-Fuzzy</a></li>
        </ul>
    </div>
    <h4 class="sidebar-box-heading">Next topic</h4>
    <div class="well sidebar-box">
        <ul class="nav nav-list">
            <li><a href="../install.html" title="next chapter">Pre-built installation</a></li>
        </ul>
    </div>


        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-fuzzy development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
            Thanks to <a href="http://scikit-image.org">scikit-image</a> team's template.
        </small>
    </div>
</body>
</html>